const { addPaging, uuid, transformToSnakeCase } = require('./lib/util');
const Promise = require('bluebird');
const {
  filter,
  isArray,
  isPlainObject,
  partition,
  map,
  extend,
  get,
  find,
} = require('lodash');
const { get: getFp } = require('lodash/fp');
const DataLoader = require('dataloader');
const { itemsPerPage } = require('../config');

class BaseModel {
  constructor(db, tableName, context) {
    this.db = db;
    this.roDb = context && context.roDb ? context.roDb : db;
    this.tableName = tableName;
    this.context = context;
    this._idLoader = new DataLoader(async ids => {
      const items = await this.db(tableName).whereIn('id', ids);
      return map(ids, id => find(items, { id }));
    });
    this._queryHelper = { limit: null, offset: null, query: null };
    this.queryHelper = query => {
      this._queryHelper.query = query;
      return this;
    };
  }

  getAll(paging) {
    const query = this.roDb(this.tableName);
    return addPaging(query, paging);
  }

  getAllMainDb(paging) {
    const query = this.db(this.tableName);
    return addPaging(query, paging);
  }

  getById(id) {
    if (!id) return id;
    return isArray(id) ? this._idLoader.loadMany(id) : this._idLoader.load(id);
  }

  getBy(field, value, paging) {
    if (field === 'id') return this.getById(value);
    return addPaging(this.db(this.tableName).where(field, value), paging);
  }

  // Wrap a model query with this to log the results before passing them back to the resolver
  log(query) {
    return Promise.resolve(query).then(result => console.log(result) || result);
  }

  // Similar to log, but will also log the SQL query that is generated by knex
  logWithQuery(query) {
    console.log(query.toString());
    return query.then(result => console.log(result) || result);
  }

  // Save can take an object or array of objects.
  // Each object is inserted or updated depending on if an id field exists
  save(input, tableOverride) {
    const tableName = tableOverride || this.tableName;
    let result = null;

    const update = item =>
      this.db(tableName)
        .where('id', item.id)
        .update(item)
        .then(() => item.id);

    if (isArray(input)) {
      const [updates, inserts] = partition(input, 'id');
      const [deletes, actualUpdates] = partition(updates, 'deleted');

      let itemsWithIds;
      let insertAction = Promise.resolve();

      if (inserts.length > 0) {
        itemsWithIds = map(inserts, item =>
          extend({}, item, { id: uuid.get() })
        );
        insertAction = this.db(tableName)
          .insert(itemsWithIds)
          .then(() => {
            return map(itemsWithIds, item => {
              this._idLoader.clear(item.id);
              return item.id;
            });
          });
      }

      let deleteIds;
      let deleteAction = Promise.resolve();

      if (deletes.length !== 0) {
        deleteIds = map(deletes, 'id');
        deleteAction = this.deleteWhereIn(deleteIds);
      }

      result = Promise.all([
        insertAction,
        deleteAction,
        Promise.each(actualUpdates, update),
      ]).then(() =>
        map(filter(input, item => !item.deleted), item =>
          (item.id ? item.id : itemsWithIds.shift().id)
        )
      );
    } else if (input.id === null || input.id === undefined) {
      const newId = uuid.get();
      input.id = newId;
      result = this.db(tableName)
        .insert(input)
        .then(() => newId);
    } else if (get(input, 'deleted', false)) {
      result = this.db(tableName)
        .where('id', input.id)
        .del();
    } else {
      result = update(input);
    }

    if (!isArray(input)) {
      this._idLoader.clear(input.id);
    }

    return result;
  }

  async isValid(model) {
    let isValid = true;
    if (model.id) {
      isValid = await this.exists(model);
    }
    return isValid;
  }

  async exists(modelOrId, tableOverride) {
    const id = isPlainObject(modelOrId) ? modelOrId.id : modelOrId;
    const doesExist = await this.roDb(tableOverride || this.tableName)
      .select(this.db.raw('1'))
      .where('id', id);

    return Boolean(doesExist.length);
  }

  async getByField(column, value) {
    const id = await this.roDb(this.tableName)
      .where(column, value)
      .then(getFp('[0].id'));

    return id;
  }

  async addEvent(type, streamType, payload) {
    let localPlayload = {};
    const keys = Object.keys(payload);
    const jobs = [];
    for (let i = 0; i < keys.length; i++)
      if (
        (typeof payload[keys[i]] !== 'object' &&
          typeof payload[keys[i]] !== 'undefined') ||
        Object.prototype.toString.call(payload[keys[i]]) === '[object Date]' ||
        (payload[keys[i]] !== null &&
          typeof payload[keys[i]] !== 'undefined' &&
          Object.prototype.hasOwnProperty.call(
            payload[keys[i]],
            '_isAMomentObject'
          ))
      )
        localPlayload[keys[i]] = payload[keys[i]];
      else if (
        payload[keys[i]] !== null &&
        typeof payload[keys[i]] !== 'undefined'
      ) {
        if (Object.prototype.hasOwnProperty.call(payload[keys[i]], 'sql'))
          jobs.push({
            key: keys[i],
            job: this.db.raw(`SELECT ${payload[keys[i]].sql} AS value`),
          });
        else localPlayload[keys[i]] = JSON.stringify(payload[keys[i]]);
      } else if (payload[keys[i]] === null) localPlayload[keys[i]] = null;

    await Promise.all(jobs.map(j => j.job)).then(results => {
      results.forEach((result, i) => {
        localPlayload[jobs[i].key] = result.rows[0].value;
      });
    });

    localPlayload = JSON.stringify(transformToSnakeCase(localPlayload)).replace(
      /'/g,
      "''"
    );

    return this.db('event_store').insert(
      transformToSnakeCase({
        type,
        payload: localPlayload,
        streamType,
        streamId: payload.id,
      })
    );
  }

  deleteById(id) {
    return this.db(this.tableName)
      .where('id', id)
      .del();
  }

  async deleteWhereIn(ids, tableOverride) {
    return Promise.all(
      ids.reduce((a, v) => {
        a.push(
          this.addEvent('deleted', tableOverride || this.tableName, { id: v })
        );
        return a;
      }, [])
    );
  }

  addPaging(paging) {
    this._queryHelper.limit = get(paging, 'limit', itemsPerPage);
    this._queryHelper.offset = get(paging, 'offset', 0);
    this._queryHelper.query
      .limit(this._queryHelper.limit)
      .offset(this._queryHelper.offset);
    return this;
  }

  addCounting() {
    this._queryHelper.query.select(
      this.db.raw('count(*) OVER() AS "total_items"')
    );
    return this;
  }

  getQuery() {
    return this._queryHelper.query;
  }

  async resolvePagedQuery() {
    const { limit, offset } = this._queryHelper;
    const results = await this.getQuery();
    const totalItems = results.length ? results[0].totalItems : 0;
    const totalPages = totalItems > 0 ? Math.ceil(totalItems / limit) : 0;
    const currentPage = offset ? Math.round(offset / limit) + 1 : 1;
    return {
      paging: {
        totalItems,
        totalPages,
        currentPage,
      },
      items: results,
    };
  }

  /**
   * get just selected field from table
   * @param fields {Array} - field names as a array
   * @param tableName {String} - if you want to use another table like view
   */
  selectFields(fields, tableName = this.tableName) {
    return this.roDb(tableName).select(...fields);
  }

  /**
   * get just selected field from table
   * @param items {Array} - item objects as an array
   * @param currentPage {Int} - with this, you can tell to want to go which page, default:1
   * @param perPageItems {Int} - with this, you can tell to show how many items per page, default:20
   */
  addRefreshPaging(items, currentPage, perPageItems) {
    const page = currentPage || 1;
    const perPage = perPageItems || 20;
    const offset = (page - 1) * perPage;

    const paginatedItems = items.slice(offset).slice(0, perPageItems);
    const totalPages = Math.ceil(items.length / perPage);

    return {
      paging: {
        page,
        perPage,
        prePage: page - 1 ? page - 1 : null,
        nextPage: (totalPages > page) ? page + 1 : null,
        total: items.length,
        totalPages,
      },
      results: paginatedItems,
    };
  }

  /**
   * get just selected field from table
   * @param items {Array} - item objects as an array
   * @param currentPage {Int} - with this, you can tell to want to go which page, default:1
   * @param perPageItems {Int} - with this, you can tell to show how many items per page, default:20
   * @param itemsLength {Int} - with this, you can tell to show how many items
   */
  addRefreshPagingWithSliced(items, currentPage, perPageItems, itemsLength) {
    const page = currentPage || 1;
    const perPage = perPageItems || 20;
    const totalPages = Math.ceil(itemsLength / perPage);
    return {
      paging: {
        page,
        perPage,
        prePage: page - 1 ? page - 1 : null,
        nextPage: (totalPages > page) ? page + 1 : null,
        total: itemsLength,
        totalPages,
      },
      results: items,
    };
  }

  async alertIt({ text, object, image, path }) {
    return this.context.generalCCCService.alertIt({ text, object, image, path });
  }

  async logIt({ eventType, eventObject, indexName }) {
    return this.context.generalCCCService.logIt({ eventType, eventObject, indexName });
  }

  async sendItToSqs(type, message, delay) {
    return this.context.generalCCCService.sendItToSqs(type, message, delay);
  }
}

module.exports = BaseModel;
